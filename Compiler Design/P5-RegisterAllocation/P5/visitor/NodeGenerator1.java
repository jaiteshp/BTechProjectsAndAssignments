//
// Generated by JTB 1.3.2
//

package visitor;
import syntaxtree.*;
import java.util.*;

/**
 * Provides default methods which visit each node in the tree in depth-first
 * order.  Your visitors may extend this class.
 */
public class NodeGenerator1<R,A> implements GJVisitor<R,A> {

   class LivInt
   {
      public int tempNum;
      public int start;
      public int end;
      public int regNum;
      public int stackLocn;

      public int getStart()   {return start;}
      public int getEnd()  {return end;}
      public int getRegNum()  {return regNum;}
      public int getStackLocn() {return stackLocn;}

      public LivInt(int tn1)
      {
         this.tempNum = tn1;
         this.start = -1;
         this.end = -1;
         this.regNum = -2;
      }

      public LivInt(LivInt l1)
      {
         this.tempNum = l1.tempNum;
         this.start = l1.start;
         this.end = l1.end;
         this.regNum = l1.regNum;
         this.stackLocn = l1.stackLocn;
      }

      public String toString()
      {
         String s = "\ntempNum: " + tempNum + " start: " + (start+1) + " end: " + (end+1);
         return s;
      }
   }

   public int R = 18;
   public int stackPos;
   public Vector <LivInt> active = new Vector<LivInt> ();
   public int totalNodes = -1;
   public int currNode = -1;
   public int argNum = 0;
   public Hashtable <String, Hashtable <Integer, Integer>> procTempMap = new Hashtable<String, Hashtable <Integer, Integer>> ();
   public Hashtable <String, Vector < LivInt >> procTempVec = new Hashtable <String, Vector < LivInt >> ();
   public Hashtable <String, Integer> procStart = new Hashtable<String, Integer>();
   public Hashtable <String, Integer> procEnd = new Hashtable<String, Integer>();
   public Hashtable <String, Set <Integer>> procTemp = new Hashtable <String, Set <Integer>> ();
   public Hashtable <String, Integer> labMap = new Hashtable<String, Integer>();
   public Vector <Set <Integer>> in = new Vector <Set <Integer>> ();
   public Vector <Set <Integer>> out = new Vector <Set <Integer>> ();
   public Vector <Set <Integer>> in1 = new Vector <Set <Integer>> ();
   public Vector <Set <Integer>> out1 = new Vector <Set <Integer>> ();
   public Vector <Set <Integer>> use = new Vector <Set <Integer>> ();
   public Vector <Set <Integer>> def = new Vector <Set <Integer>> ();
   public Vector <Set <Integer>> succ = new Vector <Set <Integer>> ();
   public boolean insideCall = false;
   public boolean storeTempInSimpleExp = false;   //For adding tn's to use[currNode] in simpleExp.

   public void expireOldIntervals(LivInt l)
   {
      LivInt l1 = new LivInt(l1);
      //Vector <LivInt> v1 = new Vector<LivInt>(active);
      Collections.sort(active, Comparator.comparing(LivInt::getEnd));

      for(int i = 0; i < active.size(); i++)
      {
         LivInt l2 = new LivInt(active.get(i));

         if(l2.end >= l1.start)  return;

         active.remove(i);


      }
   }

   public void doRAEach(String procName)
   {
      stackPos = 8;
      Vector <LivInt> v1 = new Vector<LivInt> (procTempVec.get(procName));

      active.clear();

      Collections.sort(v1, Comparator.comparing(LivInt::getStart));
      for(int i = 0; i < v1.size(); i++)
      {
         LivInt l1 = new LivInt(v1.get(i));
         expireOldIntervals(l1);
         if(l1.start == l1.end && l1.start == -1)  continue;
      }

   }

   public void doRA()
   {
      Set <String> procNameSet = procTemp.keySet();

      for(String procName1 : procNameSet)
      {
         doRAEach(procName1);
      }
   }

   public void buildProcTempVec()
   {
      Set <String> procNameSet = procTemp.keySet();

      for(String procName1 : procNameSet)
      {
         int start = procStart.get(procName1);
         int end = procEnd.get(procName1);

         Set <Integer> tempSet = new HashSet<Integer>(procTemp.get(procName1));

         Vector <LivInt> v1 = new Vector <LivInt> ();

         for(Integer tn : tempSet)
         {
            LivInt l1 = new LivInt(tn);
            for(int i = end; i >= start; i--)
            {
               Set <Integer> s2 = new HashSet<Integer>(in.get(i));
               if(s2.contains(tn))
               {
                  l1.end = i;
                  break;
               }
            }
            for(int i = start; i <= end; i++)
            {
               Set <Integer> s2 = new HashSet<Integer>(out.get(i));
               if(s2.contains(tn))
               {
                  l1.start = i;
                  break;
               }
            }
            if(l1.end != -1 && l1.start == -1)  l1.start = start;
            v1.add(l1);
         }
         Collections.sort(v1, Comparator.comparing(LivInt::getEnd));
         Collections.sort(v1, Comparator.comparing(LivInt::getStart));
         procTempVec.put(procName1, v1);
      }
   }

   public void doLivenessAnalysisEach(String procName1, int start, int end)
   {
      System.out.println("34, ng");
      for(int i = start; i <= end; i++)
      {
         in.get(i).clear();
         out.get(i).clear();
      }
      System.out.println("41, ng");

      boolean hasChanged = true;
      do
      {
         for(int i = start; i <= end; i++)
         {
            in1.set(i, new HashSet<Integer>(in.get(i)));
            out1.set(i, new HashSet<Integer>(out.get(i)));

            Set <Integer> s1 = new HashSet<Integer>(out.get(i));
            s1.removeAll(def.get(i));
            s1.addAll(use.get(i));
            in.set(i, s1);
            for (Integer j : succ.get(i))    out.get(i).addAll(in.get(j));
         }

         hasChanged = false;
         for(int i = start; i <= end; i++)
         {
            if(!in.get(i).equals(in1.get(i)) || !out.get(i).equals(out1.get(i)))
            {
               hasChanged = true;
               break;
            }
         }
      }
      while (hasChanged);
   }

   public void doLivenessAnalysis()
   {
      System.out.println("69, ng");
      Set <String> procNameSet = procTemp.keySet();

      for(String procName1 : procNameSet)
      {
         System.out.println("74, ng");
         int start = procStart.get(procName1);
         int end = procEnd.get(procName1);
         System.out.println("77, ng");
         System.out.println("Doing LA for " + procName1 + " from " + start + " to " + end);
         doLivenessAnalysisEach(procName1, start, end);
         System.out.println("80, ng");
      }
      System.out.println("79, ng");
   }

   public void initializeSets()
   {
      for(int i = 0; i <= totalNodes; i++)
      {
         Set <Integer> s1 = new HashSet <Integer> ();
         in.add(s1);
      }
      for(int i = 0; i <= totalNodes; i++)
      {
         Set <Integer> s1 = new HashSet <Integer> ();
         out.add(s1);
      }
      for(int i = 0; i <= totalNodes; i++)
      {
         Set <Integer> s1 = new HashSet <Integer> ();
         in1.add(s1);
      }
      for(int i = 0; i <= totalNodes; i++)
      {
         Set <Integer> s1 = new HashSet <Integer> ();
         out1.add(s1);
      }
      for(int i = 0; i <= totalNodes; i++)
      {
         Set <Integer> s1 = new HashSet <Integer> ();
         use.add(s1);
      }
      for(int i = 0; i <= totalNodes; i++)
      {
         Set <Integer> s1 = new HashSet <Integer> ();
         def.add(s1);
      }
      for(int i = 0; i <= totalNodes; i++)
      {
         Set <Integer> s1 = new HashSet <Integer> ();
         succ.add(s1);
      }
   }

   public R visit(NodeList n, A argu) {
      R _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this,argu);
         _count++;
      }
      return _ret;
   }

   public R visit(NodeListOptional n, A argu) {
      if ( n.present() ) {
         R _ret=null;
         int _count=0;
         for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
            e.nextElement().accept(this,argu);
            _count++;
         }
         return _ret;
      }
      else
         return null;
   }

   public R visit(NodeOptional n, A argu) {
      if ( n.present() )
         return n.node.accept(this,argu);
      else
         return null;
   }

   public R visit(NodeSequence n, A argu) {
      R _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this,argu);
         _count++;
      }
      return _ret;
   }

   public R visit(NodeToken n, A argu) { return null; }

   //
   // User-generated visitor methods below
   //

   /**
    * f0 -> "MAIN"
    * f1 -> StmtList()
    * f2 -> "END"
    * f3 -> ( Procedure() )*
    * f4 -> <EOF>
    */
   public R visit(Goal n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      succ.get(currNode).clear();
      n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> ( ( Label() )? Stmt() )*
    */
   public R visit(StmtList n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Label()
    * f1 -> "["
    * f2 -> IntegerLiteral()
    * f3 -> "]"
    * f4 -> StmtExp()
    */
   public R visit(Procedure n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      argNum = Integer.parseInt((String) n.f2.f0.toString());  //n.f2.accept(this, argu);
      currNode++;
      for(int i = 0; i < argNum; i++)    def.get(currNode).add(i);
      currNode--;
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> NoOpStmt()
    *       | ErrorStmt()
    *       | CJumpStmt()
    *       | JumpStmt()
    *       | HStoreStmt()
    *       | HLoadStmt()
    *       | MoveStmt()
    *       | PrintStmt()
    */
   public R visit(Stmt n, A argu) {
      R _ret=null;
      currNode++;
      //System.out.println(currNode);
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "NOOP"
    */
   public R visit(NoOpStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      use.get(currNode).clear();
      def.get(currNode).clear();
      succ.get(currNode).add(currNode+1);
      return _ret;
   }

   /**
    * f0 -> "ERROR"
    */
   public R visit(ErrorStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      use.get(currNode).clear();
      def.get(currNode).clear();
      succ.get(currNode).add(currNode+1);
      return _ret;
   }

   /**
    * f0 -> "CJUMP"
    * f1 -> Temp()
    * f2 -> Label()
    */
   public R visit(CJumpStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      int tn1 = Integer.parseInt((String) n.f1.accept(this, argu));
      String strLab = (String) n.f2.accept(this, argu);
      use.get(currNode).add(tn1);
      def.get(currNode).clear();
      succ.get(currNode).add(currNode+1);
      succ.get(currNode).add(labMap.get(strLab));
      return _ret;
   }

   /**
    * f0 -> "JUMP"
    * f1 -> Label()
    */
   public R visit(JumpStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      String strLab = (String) n.f1.accept(this, argu);
      use.get(currNode).clear();
      def.get(currNode).clear();
      succ.get(currNode).add(labMap.get(strLab));
      return _ret;
   }

   /**
    * f0 -> "HSTORE"
    * f1 -> Temp()
    * f2 -> IntegerLiteral()
    * f3 -> Temp()
    */
   public R visit(HStoreStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      int tn1 = Integer.parseInt((String) n.f1.accept(this, argu));
      n.f2.accept(this, argu);
      int tn2 = Integer.parseInt((String) n.f3.accept(this, argu));
      use.get(currNode).add(tn1);
      use.get(currNode).add(tn2);
      def.get(currNode).clear();
      succ.get(currNode).add(currNode+1);
      return _ret;
   }

   /**
    * f0 -> "HLOAD"
    * f1 -> Temp()
    * f2 -> Temp()
    * f3 -> IntegerLiteral()
    */
   public R visit(HLoadStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      int tn1 = Integer.parseInt((String) n.f1.accept(this, argu));
      int tn2 = Integer.parseInt((String) n.f2.accept(this, argu));
      n.f3.accept(this, argu);
      use.get(currNode).add(tn2);
      def.get(currNode).add(tn1);
      succ.get(currNode).add(currNode+1);
      return _ret;
   }

   /**
    * f0 -> "MOVE"
    * f1 -> Temp()
    * f2 -> Exp()
    */
   public R visit(MoveStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      int tn1 = Integer.parseInt((String) n.f1.accept(this, argu));
      n.f2.accept(this, argu);
      def.get(currNode).add(tn1);
      succ.get(currNode).add(currNode+1);
      return _ret;
   }

   /**
    * f0 -> "PRINT"
    * f1 -> SimpleExp()
    */
   public R visit(PrintStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      storeTempInSimpleExp = true;
      n.f1.accept(this, argu);
      storeTempInSimpleExp = false;
      def.get(currNode).clear();
      succ.get(currNode).add(currNode+1);
      return _ret;
   }

   /**
    * f0 -> Call()
    *       | HAllocate()
    *       | BinOp()
    *       | SimpleExp()
    */
   public R visit(Exp n, A argu) {
      R _ret=null;
      if(n.f0.which == 3)
      {
         storeTempInSimpleExp = true;
         _ret = (R) n.f0.accept(this, argu);
         storeTempInSimpleExp = false;
      }
      else
      {
         _ret = (R) n.f0.accept(this, argu);
      }
      return _ret;
   }

   /**
    * f0 -> "BEGIN"
    * f1 -> StmtList()
    * f2 -> "RETURN"
    * f3 -> SimpleExp()
    * f4 -> "END"
    */
   public R visit(StmtExp n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      currNode++;
      //System.out.println(currNode);
      n.f2.accept(this, argu);
      storeTempInSimpleExp = true;
      n.f3.accept(this, argu);
      storeTempInSimpleExp = false;
      n.f4.accept(this, argu);
      def.get(currNode).clear();
      succ.get(currNode).clear();
      return _ret;
   }

   /**
    * f0 -> "CALL"
    * f1 -> SimpleExp()
    * f2 -> "("
    * f3 -> ( Temp() )*
    * f4 -> ")"
    */
   public R visit(Call n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      storeTempInSimpleExp = true;
      n.f1.accept(this, argu);
      storeTempInSimpleExp = false;
      n.f2.accept(this, argu);
      insideCall = true;
      n.f3.accept(this, argu);
      insideCall = false;
      n.f4.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "HALLOCATE"
    * f1 -> SimpleExp()
    */
   public R visit(HAllocate n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      storeTempInSimpleExp = true;
      n.f1.accept(this, argu);
      storeTempInSimpleExp = false;
      return _ret;
   }

   /**
    * f0 -> Operator()
    * f1 -> Temp()
    * f2 -> SimpleExp()
    */
   public R visit(BinOp n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      int tn2 = Integer.parseInt((String) n.f1.accept(this, argu));
      use.get(currNode).add(tn2);
      storeTempInSimpleExp = true;
      n.f2.accept(this, argu);
      storeTempInSimpleExp = false;
      return _ret;
   }

   /**
    * f0 -> "LE"
    *       | "NE"
    *       | "PLUS"
    *       | "MINUS"
    *       | "TIMES"
    *       | "DIV"
    */
   public R visit(Operator n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Temp()
    *       | IntegerLiteral()
    *       | Label()
    */
   public R visit(SimpleExp n, A argu) {
      R _ret=null;
      _ret = (R) n.f0.accept(this, argu);
      if(n.f0.which == 0 && storeTempInSimpleExp)    use.get(currNode).add(Integer.parseInt((String) _ret));
      return _ret;
   }

   /**
    * f0 -> "TEMP"
    * f1 -> IntegerLiteral()
    */
   public R visit(Temp n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
//      _ret = (R) n.f1.f0.toString();
      //int tn1 = Integer.parseInt(((String) _ret));
//      int tn1 = (int) n.f1.f0.toString();
//      if(insideCall)    use.get(currNode).add(tn1);
      _ret = n.f1.accept(this, argu);
      if(insideCall) use.get(currNode).add(Integer.parseInt((String) _ret));
      //_ret = (R) tn1;
      return _ret;
   }

   /**
    * f0 -> <INTEGER_LITERAL>
    */
   public R visit(IntegerLiteral n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      _ret = (R) n.f0.toString();
      return _ret;
   }

   /**
    * f0 -> <IDENTIFIER>
    */
   public R visit(Label n, A argu) {
      R _ret= (R) n.f0.toString();
      n.f0.accept(this, argu);
      return _ret;
   }

}
